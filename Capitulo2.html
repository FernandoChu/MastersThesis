<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>HoTTEST Summer School 2022 Lecture Notes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap"
    rel="stylesheet">
</head>

<body class="text-page">
  <main>
    <div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

      <article>

        <p>module CapÃ­tulo2 where</p>
        <p>open import CapÃ­tulo1 public</p>
        <hr />
        <p>â€“ SecciÃ³n 2.2. Los tipos son 1-grupoides</p>
        <p>â€“ Lema 2.2.1. <em>âˆ™</em> : {X : ğ’° ğ’¾} {x y z : X} â†’ x â‰¡ y â†’ y
        â‰¡ z â†’ x â‰¡ z (refl x) âˆ™ (refl x) = (refl x) infixl 30
        <em>âˆ™</em></p>
        <p>â€“ Lema 2.2.2. refl-left : {X : ğ’° ğ’¾} {x y : X} {p : x â‰¡ y} â†’
        refl x âˆ™ p â‰¡ p refl-left {ğ“¤} {X} {x} {x} {refl x} = refl (refl
        x)</p>
        <p>refl-right : {X : ğ’° ğ’¾} {x y : X} {p : x â‰¡ y} â†’ p âˆ™ refl y â‰¡ p
        refl-right {ğ“¤} {X} {x} {y} {refl x} = refl (refl x)</p>
        <p>â€“ Lema 2.2.3. âˆ™-assoc : {X : ğ’° ğ’¾} {x y z t : X} (p : x â‰¡ y)
        {q : y â‰¡ z} {r : z â‰¡ t} â†’ (p âˆ™ q) âˆ™ r â‰¡ p âˆ™ (q âˆ™ r) âˆ™-assoc
        (refl x) {refl x} {refl x} = refl (refl x)</p>
        <p>â€“ Lema 2.2.4. <em>â»Â¹ : {X : ğ’° ğ’¾} â†’ {x y : X} â†’ x â‰¡ y â†’ y â‰¡ x
        (refl x)â»Â¹ = refl x infix 40 </em>â»Â¹</p>
        <p>â»Â¹-leftâˆ™ : {X : ğ’° ğ’¾} {x y : X} (p : x â‰¡ y) â†’ p â»Â¹ âˆ™ p â‰¡ refl
        y â»Â¹-leftâˆ™ (refl x) = refl (refl x)</p>
        <p>â»Â¹-rightâˆ™ : {X : ğ’° ğ’¾} {x y : X} (p : x â‰¡ y) â†’ p âˆ™ p â»Â¹ â‰¡ refl
        x â»Â¹-rightâˆ™ (refl x) = refl (refl x)</p>
        <p>â€“ Lema 2.2.6. â»Â¹-involutive : {X : ğ’° ğ’¾} {x y : X} (p : x â‰¡ y)
        â†’ (p â»Â¹)â»Â¹ â‰¡ p â»Â¹-involutive (refl x) = refl (refl x)</p>
        <p>â»Â¹-âˆ™ : {X : ğ’° ğ’¾} {x y z : X} (p : x â‰¡ y) {q : y â‰¡ z} â†’ (p âˆ™
        q)â»Â¹ â‰¡ (q)â»Â¹ âˆ™ (p)â»Â¹ â»Â¹-âˆ™ (refl x) {refl x} = refl (refl x)</p>
        <p>â€“ Helpers tomados de â€“
        https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#2708
        begin_ : {X : ğ’° ğ’¾} {x y : X} â†’ x â‰¡ y â†’ x â‰¡ y begin_ xâ‰¡y = xâ‰¡y
        infix 1 begin_</p>
        <p><em>â‰¡âŸ¨âŸ©</em> : {X : ğ’° ğ’¾} (x {y} : X) â†’ x â‰¡ y â†’ x â‰¡ y _ â‰¡âŸ¨âŸ©
        xâ‰¡y = xâ‰¡y</p>
        <p>step-â‰¡ : {X : ğ’° ğ’¾} (x {y z} : X) â†’ y â‰¡ z â†’ x â‰¡ y â†’ x â‰¡ z
        step-â‰¡ _ yâ‰¡z xâ‰¡y = xâ‰¡y âˆ™ yâ‰¡z syntax step-â‰¡ x yâ‰¡z xâ‰¡y = x â‰¡âŸ¨ xâ‰¡y
        âŸ© yâ‰¡z</p>
        <p>step-â‰¡Ë˜ : {X : ğ’° ğ’¾} (x {y z} : X) â†’ y â‰¡ z â†’ y â‰¡ x â†’ x â‰¡ z
        step-â‰¡Ë˜ _ yâ‰¡z yâ‰¡x = (yâ‰¡x)â»Â¹ âˆ™ yâ‰¡z syntax step-â‰¡Ë˜ x yâ‰¡z yâ‰¡x = x
        â‰¡Ë˜âŸ¨ yâ‰¡x âŸ© yâ‰¡z infixr 2 <em>â‰¡âŸ¨âŸ©</em> step-â‰¡ step-â‰¡Ë˜</p>
        <p><em>âˆ : {X : ğ’° ğ’¾} (x : X) â†’ x â‰¡ x </em>âˆ x = refl x infix 3
        _âˆ</p>
        <hr />
        <p>â€“ SecciÃ³n 2.3. Funciones y functores</p>
        <p>â€“ Lemma 2.3.1. ap : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} (f : X â†’ Y) {x xâ€™ :
        X} â†’ x â‰¡ xâ€™ â†’ f x â‰¡ f xâ€™ ap f {x} {xâ€™} (refl x) = refl (f x)</p>
        <p>â€“ Lemma 2.3.3. ap-âˆ™ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} (f : X â†’ Y) {x y z
        : X} (p : x â‰¡ y) (q : y â‰¡ z) â†’ ap f (p âˆ™ q) â‰¡ ap f p âˆ™ ap f q
        ap-âˆ™ f (refl x) (refl x) = refl (refl (f x))</p>
        <p>â€“ Lemma 2.3.4. apâ»Â¹ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} (f : X â†’ Y) {x y :
        X} (p : x â‰¡ y) â†’ (ap f p)â»Â¹ â‰¡ ap f (p â»Â¹) apâ»Â¹ f {x} {y} p =
        (q4)â»Â¹ âˆ™ (h1ap)â»Â¹ âˆ™ q6 âˆ™ h2q5 âˆ™ q3 where q1 : p â»Â¹ âˆ™ p â‰¡ refl y
        q1 = â»Â¹-leftâˆ™ p g : (y â‰¡ y) â†’ (f y â‰¡ f y) g = Î» r â†’ ap f r gq1 :
        ap f (p â»Â¹ âˆ™ p) â‰¡ refl (f y) gq1 = ap g q1 q2 : ap f (p â»Â¹ âˆ™ p)
        â‰¡ ap f (p â»Â¹) âˆ™ ap f p q2 = ap-âˆ™ f (p â»Â¹) p h1 : (f y â‰¡ f y) â†’
        (f y â‰¡ f x) h1 = Î» r â†’ r âˆ™ ((ap f p)â»Â¹) h1ap : (ap f (p â»Â¹) âˆ™ ap
        f p) âˆ™ ((ap f p)â»Â¹) â‰¡ refl (f y) âˆ™ ((ap f p)â»Â¹) h1ap = ap h1
        ((q2 â»Â¹) âˆ™ gq1) q3 : (ap f (p â»Â¹)) âˆ™ refl (f x) â‰¡ ap f (p â»Â¹) q3
        = refl-right q4 : refl (f y) âˆ™ (ap f p)â»Â¹ â‰¡ (ap f p)â»Â¹ q4 =
        refl-left q5 : ap f p âˆ™ ap f p â»Â¹ â‰¡ refl (f x) q5 = â»Â¹-rightâˆ™
        (ap f p) h2 : (f x â‰¡ f x) â†’ (f y â‰¡ f x) h2 = Î» r â†’ ap f (p â»Â¹) âˆ™
        r h2q5 : ap f (p â»Â¹) âˆ™ (ap f p âˆ™ ap f p â»Â¹) â‰¡ ap f (p â»Â¹) âˆ™
        (refl (f x)) h2q5 = ap h2 q5 q6 : (ap f (p â»Â¹) âˆ™ ap f p) âˆ™ ((ap
        f p)â»Â¹) â‰¡ ap f (p â»Â¹) âˆ™ (ap f p âˆ™ (ap f p)â»Â¹) q6 = âˆ™-assoc (ap f
        (p â»Â¹))</p>
        <hr />
        <p>â€“ SecciÃ³n 2.4. Funciones dependientes y fibraciones</p>
        <p>â€“ Definition 2.1.7. ğ’°âˆ™ : (ğ’¾ : Level) â†’ ğ’° (ğ’¾ âº) ğ’°âˆ™ ğ’¾ = Î£ A ê‰
        (ğ’° ğ’¾) , A</p>
        <p>â€“ Definition 2.1.8 Î© : ((A , a) : (ğ’°âˆ™ ğ’¾)) â†’ ğ’°âˆ™ ğ’¾ Î© (A , a) =
        ((a â‰¡ a) , refl a)</p>
        <p>Î©â¿ : (n : â„•) â†’ ((A , a) : (ğ’°âˆ™ ğ’¾)) â†’ ğ’°âˆ™ ğ’¾ Î©â¿ 0 (A , a) = (A ,
        a) Î©â¿ (succ n) (A , a) = Î©â¿ n (Î© (A , a))</p>
        <hr />
        <p>â€“ Section 2.2 Functions are functors</p>
        <p>â€“ Lemma 2.2.2 iii) ap-âˆ˜ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} {Z : ğ’° ğ“€} (f :
        X â†’ Y) (g : Y â†’ Z) {x y : X} (p : x â‰¡ y) â†’ ap (g âˆ˜ f) p â‰¡ (ap g
        âˆ˜ ap f) p ap-âˆ˜ f g (refl x) = refl (refl (g (f x)))</p>
        <p>â€“ Lemma 2.2.2 iv) ap-id : {X : ğ’° ğ’¾} {x y : X} (p : x â‰¡ y) â†’
        ap id p â‰¡ p ap-id (refl x) = refl (refl x)</p>
        <p>â€“ Some more helpers ap-const : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} {aâ‚ aâ‚‚ :
        A} (p : aâ‚ â‰¡ aâ‚‚) (c : B) â†’ ap (Î» _ â†’ c) p â‰¡ refl c ap-const
        (refl <em>) c = refl </em></p>
        <p>âˆ™-left-cancel : {X : ğ’° ğ’¾} {x y z : X} (p : x â‰¡ y) {q r : y â‰¡
        z} â†’ p âˆ™ q â‰¡ p âˆ™ r â†’ q â‰¡ r âˆ™-left-cancel p {q} {r} path = begin
        q â‰¡Ë˜âŸ¨ refl-left âŸ© refl _ âˆ™ q â‰¡Ë˜âŸ¨ ap (<em>âˆ™ q) (â»Â¹-leftâˆ™ p) âŸ© (p
        â»Â¹ âˆ™ p) âˆ™ q â‰¡âŸ¨ âˆ™-assoc (p â»Â¹) âŸ© p â»Â¹ âˆ™ (p âˆ™ q) â‰¡âŸ¨ ap ((p â»Â¹)
        âˆ™</em>) path âŸ© p â»Â¹ âˆ™ (p âˆ™ r) â‰¡Ë˜âŸ¨ âˆ™-assoc (p â»Â¹) âŸ© (p â»Â¹ âˆ™ p) âˆ™
        r â‰¡âŸ¨ ap (<em>âˆ™ r) (â»Â¹-leftâˆ™ p) âŸ© refl </em> âˆ™ r â‰¡âŸ¨ refl-left âŸ© r
        âˆ</p>
        <p>âˆ™-right-cancel : {X : ğ’° ğ’¾} {x y z : X} (p : x â‰¡ y) {q : x â‰¡
        y} {r : y â‰¡ z} â†’ p âˆ™ r â‰¡ q âˆ™ r â†’ p â‰¡ q âˆ™-right-cancel p {q} {r}
        path = begin p â‰¡Ë˜âŸ¨ refl-right âŸ© p âˆ™ refl _ â‰¡Ë˜âŸ¨ ap (p âˆ™<em>)
        (â»Â¹-rightâˆ™ r) âŸ© p âˆ™ (r âˆ™ r â»Â¹) â‰¡Ë˜âŸ¨ âˆ™-assoc p âŸ© (p âˆ™ r) âˆ™ r â»Â¹ â‰¡âŸ¨
        ap (</em>âˆ™ (r â»Â¹)) path âŸ© (q âˆ™ r) âˆ™ r â»Â¹ â‰¡âŸ¨ âˆ™-assoc q âŸ© q âˆ™ (r âˆ™
        r â»Â¹) â‰¡âŸ¨ ap (q âˆ™<em>) (â»Â¹-rightâˆ™ r) âŸ© q âˆ™ refl </em> â‰¡âŸ¨
        refl-right âŸ© q âˆ</p>
        <hr />
        <p>â€“ Section 2.3 Type families are fibrations</p>
        <p>â€“ Lemma 2.3.1. tr : {A : ğ’° ğ’¾} (P : A â†’ ğ’° ğ’¿) {x y : A} â†’ x â‰¡ y
        â†’ P x â†’ P y tr P (refl x) = id</p>
        <p>â€“ Lemma 2.3.2. lift : {A : ğ’° ğ’¾} {P : A â†’ ğ’° ğ’¿} {x y : A} (u :
        P x) (p : x â‰¡ y) â†’ ((x , u) â‰¡ (y , tr P p u)) lift u (refl x) =
        refl (x , u)</p>
        <p>â€“ Lemma 2.3.4. apd : {A : ğ’° ğ’¾} {P : A â†’ ğ’° ğ’¿} (f : (x : A) â†’ P
        x) {x y : A} (p : x â‰¡ y) â†’ tr P p (f x) â‰¡ f y apd f (refl x) =
        refl (f x)</p>
        <p>â€“ Lemma 2.3.5. trconst : {A : ğ’° ğ’¾} (B : ğ’° ğ’¿) {x y : A} (p : x
        â‰¡ y) (b : B) â†’ tr (Î» - â†’ B) p b â‰¡ b trconst B (refl x) b = refl
        b</p>
        <p>â€“ Lemma 2.3.8. apd-trconst : {A : ğ’° ğ’¾} (B : ğ’° ğ’¿) {x y : A} (f
        : A â†’ B) (p : x â‰¡ y) â†’ apd f p â‰¡ trconst B p (f x) âˆ™ ap f p
        apd-trconst B f (refl x) = refl (refl (f x))</p>
        <p>â€“ Lemma 2.3.9. â€“ (Slight generalization for the ua-âˆ˜ proof)
        tr-âˆ˜ : {A : ğ’° ğ’¾} (P : A â†’ ğ’° ğ’¿) {x y z : A} (p : x â‰¡ y) (q : y â‰¡
        z) â†’ (tr P q) âˆ˜ (tr P p) â‰¡ tr P (p âˆ™ q) tr-âˆ˜ P (refl x) (refl x)
        = refl id</p>
        <hr />
        <p>â€“ Section 2.4 Homotopies and equivalences</p>
        <p><em>âˆ¼</em> : {X : ğ’° ğ’¾} {P : X â†’ ğ’° ğ’¿} â†’ ((x : X) â†’ P x) â†’ ((x
        : X) â†’ P x) â†’ ğ’° (ğ’¾ âŠ” ğ’¿) f âˆ¼ g = âˆ€ x â†’ f x â‰¡ g x</p>
        <p>âˆ¼-refl : {X : ğ’° ğ’¾} {P : X â†’ ğ’° ğ’¿} (f : (x : X) â†’ P x) â†’ (f âˆ¼
        f) âˆ¼-refl f = Î» x â†’ (refl (f x))</p>
        <p>âˆ¼-sym : {X : ğ’° ğ’¾} {P : X â†’ ğ’° ğ’¿} â†’ (f g : (x : X) â†’ P x) â†’ (f
        âˆ¼ g) â†’ (g âˆ¼ f) âˆ¼-sym f g H = Î» x â†’ (H x)â»Â¹</p>
        <p>âˆ¼-trans : {X : ğ’° ğ’¾} {P : X â†’ ğ’° ğ’¿} â†’ (f g h : (x : X) â†’ P x) â†’
        (f âˆ¼ g) â†’ (g âˆ¼ h) â†’ (f âˆ¼ h) âˆ¼-trans f g h H1 H2 = Î» x â†’ (H1 x) âˆ™
        (H2 x)</p>
        <p>â€“ Lemma 2.4.3. âˆ¼-naturality : {X : ğ’° ğ’¾} {A : ğ’° ğ’¿} (f g : X â†’
        A) (H : f âˆ¼ g) {x y : X} {p : x â‰¡ y} â†’ H x âˆ™ ap g p â‰¡ ap f p âˆ™ H
        y âˆ¼-naturality f g H {x} {_} {refl a} = refl-right âˆ™ refl-left
        â»Â¹</p>
        <p>â€“ Corollary 2.4.4. ~-id-naturality : {A : ğ’° ğ’¾} (f : A â†’ A) (H
        : f âˆ¼ id) {x : A} â†’ (H (f x)) â‰¡ (ap f (H x)) ~-id-naturality f H
        {x} = begin H (f x) â‰¡Ë˜âŸ¨ refl-right âŸ© H (f x) âˆ™ (refl (f x)) â‰¡Ë˜âŸ¨
        i âŸ© H (f x) âˆ™ (H x âˆ™ (H x)â»Â¹) â‰¡Ë˜âŸ¨ âˆ™-assoc (H (f x)) âŸ© (H (f x) âˆ™
        H x) âˆ™ (H x)â»Â¹ â‰¡Ë˜âŸ¨ ii âŸ© (H (f x) âˆ™ (ap id (H x))) âˆ™ (H x)â»Â¹ â‰¡âŸ¨
        iii âŸ© (ap f (H x) âˆ™ (H x)) âˆ™ (H x)â»Â¹ â‰¡âŸ¨ âˆ™-assoc (ap f (H x)) âŸ©
        ap f (H x) âˆ™ ((H x) âˆ™ (H x)â»Â¹) â‰¡âŸ¨ iv âŸ© ap f (H x) âˆ™ (refl (f x))
        â‰¡âŸ¨ refl-right âŸ© ap f (H x) âˆ where i = ap (H (f x) âˆ™<em>)
        (â»Â¹-rightâˆ™ (H x)) ii = ap (Î» - â†’ (H (f x) âˆ™ (-)) âˆ™ (H x)â»Â¹)
        (ap-id (H x)) iii = ap (</em>âˆ™ (H x)â»Â¹) (âˆ¼-naturality f id H) iv
        = ap (ap f (H x) âˆ™_) (â»Â¹-rightâˆ™ (H x))</p>
        <p>qinv : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} â†’ (A â†’ B) â†’ ğ’° (ğ’¾ âŠ” ğ’¿) qinv f = Î£ g
        ê‰ (codomain f â†’ domain f) , (f âˆ˜ g âˆ¼ id) Ã— (g âˆ˜ f âˆ¼ id)</p>
        <p>â€“ Example 2.4.7. qinv-id-id : (A : ğ’° ğ’¾) â†’ qinv (ğ‘–ğ‘‘ A)
        qinv-id-id A = (ğ‘–ğ‘‘ A) , refl , refl</p>
        <p>is-equiv : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} â†’ (A â†’ B) â†’ ğ’° (ğ’¾ âŠ” ğ’¿) is-equiv
        f = (Î£ g ê‰ (codomain f â†’ domain f) , (f âˆ˜ g âˆ¼ id)) Ã— (Î£ h ê‰
        (codomain f â†’ domain f) , (h âˆ˜ f âˆ¼ id))</p>
        <p>invs-are-equivs : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} (f : A â†’ B) â†’ (qinv f)
        â†’ (is-equiv f) invs-are-equivs f ( g , Î± , Î² ) = ( (g , Î±) , (g
        , Î²) )</p>
        <p>equivs-are-invs : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} (f : A â†’ B) â†’ (is-equiv
        f) â†’ (qinv f) equivs-are-invs f ( (g , Î±) , (h , Î²) ) = ( g , Î±
        , Î²â€™ ) where Î³ : (x : codomain f) â†’ (g x â‰¡ h x) Î³ x = begin g x
        â‰¡Ë˜âŸ¨ Î² (g x) âŸ© h (f (g x)) â‰¡âŸ¨ ap h (Î± x) âŸ© h x âˆ Î²â€™ : g âˆ˜ f âˆ¼ ğ‘–ğ‘‘
        (domain f) Î²â€™ x = Î³ (f x) âˆ™ Î² x</p>
        <p><em>â‰ƒ</em> : ğ’° ğ’¾ â†’ ğ’° ğ’¿ â†’ ğ’° (ğ’¾ âŠ” ğ’¿) A â‰ƒ B = Î£ f ê‰ (A â†’ B),
        is-equiv f</p>
        <p>â€“ Helpers to get the quasi-inverse data from an equiv â‰ƒ-â†’ :
        {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} â†’ X â‰ƒ Y â†’ (X â†’ Y) â‰ƒ-â†’ (f , eqv) = f</p>
        <p>â‰ƒ-â† : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} â†’ X â‰ƒ Y â†’ (Y â†’ X) â‰ƒ-â† (f , eqv) =
        let (g , Îµ , Î·) = equivs-are-invs f eqv in g</p>
        <p>â‰ƒ-Îµ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} â†’ (equiv : (X â‰ƒ Y)) â†’ ((prâ‚ equiv)
        âˆ˜ (â‰ƒ-â† equiv) âˆ¼ id) â‰ƒ-Îµ (f , eqv) = let (g , Îµ , Î·) =
        equivs-are-invs f eqv in Îµ</p>
        <p>â‰ƒ-Î· : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} â†’ (equiv : (X â‰ƒ Y)) â†’ ((â‰ƒ-â† equiv)
        âˆ˜ (prâ‚ equiv) âˆ¼ id) â‰ƒ-Î· (f , eqv) = let (g , Îµ , Î·) =
        equivs-are-invs f eqv in Î·</p>
        <p>â€“ Lemma 2.4.12. i) â‰ƒ-refl : (X : ğ’° ğ’¾) â†’ X â‰ƒ X â‰ƒ-refl X = ( ğ‘–ğ‘‘
        X , invs-are-equivs (ğ‘–ğ‘‘ X) (qinv-id-id X) )</p>
        <p>â€“ Lemma 2.4.12. ii) â‰ƒ-sym : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} â†’ X â‰ƒ Y â†’ Y â‰ƒ
        X â‰ƒ-sym ( f , e ) = let ( fâ»Â¹ , p , q) = ( equivs-are-invs f e )
        in ( fâ»Â¹ , invs-are-equivs fâ»Â¹ (f , q , p) )</p>
        <p>â€“ Lemma 2.4.12. iii) â‰ƒ-trans-helper : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} {C
        : ğ’° ğ“€} (eqvf : A â‰ƒ B) (eqvg : B â‰ƒ C) â†’ is-equiv (prâ‚ eqvg âˆ˜ prâ‚
        eqvf) â‰ƒ-trans-helper ( f , ef ) ( g , eg ) = let ( fâ»Â¹ , pf , qf
        ) = ( equivs-are-invs f ef ) ( gâ»Â¹ , pg , qg ) = (
        equivs-are-invs g eg ) h1 : ((g âˆ˜ f) âˆ˜ (fâ»Â¹ âˆ˜ gâ»Â¹) âˆ¼ id) h1 x =
        begin g (f (fâ»Â¹ (gâ»Â¹ x))) â‰¡âŸ¨ ap g (pf (gâ»Â¹ x)) âŸ© g (gâ»Â¹ x) â‰¡âŸ¨ pg
        x âŸ© x âˆ h2 : ((fâ»Â¹ âˆ˜ gâ»Â¹) âˆ˜ (g âˆ˜ f) âˆ¼ id) h2 x = begin fâ»Â¹ (gâ»Â¹
        (g (f x))) â‰¡âŸ¨ ap fâ»Â¹ (qg (f x)) âŸ© fâ»Â¹ (f x) â‰¡âŸ¨ qf x âŸ© x âˆ in
        invs-are-equivs (g âˆ˜ f) ((fâ»Â¹ âˆ˜ gâ»Â¹) , h1 , h2)</p>
        <p>â‰ƒ-trans : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} {C : ğ’° ğ“€} â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ
        C â‰ƒ-trans eqvf@( f , ef ) eqvg@( g , eg ) = let ( fâ»Â¹ , pf , qf
        ) = ( equivs-are-invs f ef ) ( gâ»Â¹ , pg , qg ) = (
        equivs-are-invs g eg ) h1 : ((g âˆ˜ f) âˆ˜ (fâ»Â¹ âˆ˜ gâ»Â¹) âˆ¼ id) h1 x =
        begin g (f (fâ»Â¹ (gâ»Â¹ x))) â‰¡âŸ¨ ap g (pf (gâ»Â¹ x)) âŸ© g (gâ»Â¹ x) â‰¡âŸ¨ pg
        x âŸ© x âˆ h2 : ((fâ»Â¹ âˆ˜ gâ»Â¹) âˆ˜ (g âˆ˜ f) âˆ¼ id) h2 x = begin fâ»Â¹ (gâ»Â¹
        (g (f x))) â‰¡âŸ¨ ap fâ»Â¹ (qg (f x)) âŸ© fâ»Â¹ (f x) â‰¡âŸ¨ qf x âŸ© x âˆ in ((g
        âˆ˜ f) , â‰ƒ-trans-helper eqvf eqvg)</p>
        <hr />
        <p>â€“ 2.5 The higher groupoid structure of type formers</p>
        <hr />
        <p>â€“ 2.6 Cartesian product types</p>
        <p>pairÃ—â¼â»Â¹ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} {w wâ€™ : X Ã— Y} â†’ (w â‰¡ wâ€™) â†’
        ((prâ‚ w â‰¡ prâ‚ wâ€™) Ã— (prâ‚‚ w â‰¡ prâ‚‚ wâ€™)) pairÃ—â¼â»Â¹ (refl w) = ( refl
        (prâ‚ w) , refl (prâ‚‚ w) )</p>
        <p>pairÃ—â¼ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} {w wâ€™ : X Ã— Y} â†’ ((prâ‚ w â‰¡ prâ‚
        wâ€™) Ã— (prâ‚‚ w â‰¡ prâ‚‚ wâ€™)) â†’ (w â‰¡ wâ€™) pairÃ—â¼ {ğ’¾} {ğ’¿} {X} {Y} {w1 ,
        w2} {wâ€™1 , wâ€™2} (refl w1 , refl w2) = refl (w1 , w2)</p>
        <p>â€“ Theorem 2.6.2 Ã—-â‰¡-â‰ƒ : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} {w wâ€™ : X Ã— Y} â†’
        (w â‰¡ wâ€™) â‰ƒ ((prâ‚ w â‰¡ prâ‚ wâ€™) Ã— (prâ‚‚ w â‰¡ prâ‚‚ wâ€™)) Ã—-â‰¡-â‰ƒ {ğ’¾} {ğ’¿}
        {X} {Y} {w1 , w2} {wâ€™1 , wâ€™2} = pairÃ—â¼â»Â¹ , invs-are-equivs
        pairÃ—â¼â»Â¹ (pairÃ—â¼ , Î± , Î²) where Î± : (pq : (w1 â‰¡ wâ€™1) Ã— (w2 â‰¡
        wâ€™2)) â†’ pairÃ—â¼â»Â¹ (pairÃ—â¼ pq) â‰¡ pq Î± (refl w1 , refl w2) = refl
        (refl w1 , refl w2) Î² : (p : (w1 , w2 â‰¡ wâ€™1 , wâ€™2)) â†’ pairÃ—â¼
        (pairÃ—â¼â»Â¹ p) â‰¡ p Î² (refl (w1 , w2)) = refl (refl (w1 , w2))</p>
        <p>Ã—-uniq : {X : ğ’° ğ’¾} {Y : ğ’° ğ’¿} {z : X Ã— Y} â†’ z â‰¡ (prâ‚ z , prâ‚‚
        z) Ã—-uniq {ğ’¾} {ğ’¿} {X} {Y} {z} = pairÃ—â¼ (refl (prâ‚ z) , refl (prâ‚‚
        z))</p>
        <p>trAÃ—B : (Z : ğ’° ğ’¾) (A : Z â†’ ğ’° ğ’¿) (B : Z â†’ ğ’° ğ“€) (z w : Z) (p :
        z â‰¡ w) (x : A z Ã— B z) â†’ tr (Î» - â†’ A - Ã— B -) p x â‰¡ (tr A p (prâ‚
        x) , tr B p (prâ‚‚ x)) trAÃ—B Z A B z w (refl z) x = Ã—-uniq</p>
        <hr />
        <p>â€“ 2.7 Î£-types</p>
        <p>â€“ Theorem 2.7.2. pairâ¼â»Â¹ : {X : ğ’° ğ’¾} {Y : X â†’ ğ’° ğ’¿} {w wâ€™ : Î£
        Y} â†’ (w â‰¡ wâ€™) â†’ (Î£ p ê‰ (prâ‚ w â‰¡ prâ‚ wâ€™) , tr Y p (prâ‚‚ w) â‰¡ (prâ‚‚
        wâ€™)) pairâ¼â»Â¹ (refl w) = ( refl (prâ‚ w) , refl (prâ‚‚ w) )</p>
        <p>pairâ¼ : {X : ğ’° ğ’¾} {Y : X â†’ ğ’° ğ’¿} {w wâ€™ : Î£ Y} â†’ (Î£ p ê‰ (prâ‚ w
        â‰¡ prâ‚ wâ€™) , tr Y p (prâ‚‚ w) â‰¡ (prâ‚‚ wâ€™)) â†’ (w â‰¡ wâ€™) pairâ¼ {ğ’¾} {ğ’¿}
        {X} {Y} {w1 , w2} {wâ€™1 , wâ€™2} (refl w1 , refl w2) = refl (w1 ,
        w2)</p>
        <p>Î£-â‰¡-â‰ƒ : {X : ğ’° ğ’¾} {Y : X â†’ ğ’° ğ’¿} {w wâ€™ : Î£ Y} â†’ (w â‰¡ wâ€™) â‰ƒ (Î£
        p ê‰ (prâ‚ w â‰¡ prâ‚ wâ€™) , tr Y p (prâ‚‚ w) â‰¡ (prâ‚‚ wâ€™)) Î£-â‰¡-â‰ƒ {ğ’¾} {ğ’¿}
        {X} {Y} {w1 , w2} {wâ€™1 , wâ€™2} = pairâ¼â»Â¹ , invs-are-equivs
        pairâ¼â»Â¹ (pairâ¼ , Î± , Î²) where Î± : (pq : (Î£ p ê‰ w1 â‰¡ wâ€™1 , tr Y p
        w2 â‰¡ wâ€™2)) â†’ pairâ¼â»Â¹ (pairâ¼ pq) â‰¡ pq Î± (refl w1 , refl w2) =
        refl (refl w1 , refl w2) Î² : (p : (w1 , w2 â‰¡ wâ€™1 , wâ€™2)) â†’ pairâ¼
        (pairâ¼â»Â¹ p) â‰¡ p Î² (refl (w1 , w2)) = refl (refl (w1 , w2))</p>
        <p>â€“ Additional lemma prâ‚pairâ¼â»Â¹-is-ap : {X : ğ’° ğ’¾} {Y : X â†’ ğ’° ğ’¿}
        {w wâ€™ : Î£ Y} â†’ (p : w â‰¡ wâ€™) â†’ (prâ‚ (pairâ¼â»Â¹ p)) â‰¡ (ap prâ‚ p)
        prâ‚pairâ¼â»Â¹-is-ap (refl w) = refl (prâ‚ (pairâ¼â»Â¹ (refl w)))</p>
        <p>â€“ Corollary 2.7.3. Î£-uniq : {X : ğ’° ğ’¾} {P : X â†’ ğ’° ğ’¿} (z : Î£ P)
        â†’ z â‰¡ (prâ‚ z , prâ‚‚ z) Î£-uniq z = pairâ¼ (refl _ , refl _)</p>
        <hr />
        <p>â€“ 2.8 The unit type</p>
        <p>ğŸ™-â‰¡-â‰ƒ : (x y : ğŸ™) â†’ (x â‰¡ y) â‰ƒ ğŸ™ ğŸ™-â‰¡-â‰ƒ â‹† â‹† = f ,
        invs-are-equivs f (g , Î± , Î²) where f : â‹† â‰¡ â‹† â†’ ğŸ™ f p = â‹† g : ğŸ™
        â†’ â‹† â‰¡ â‹† g â‹† = refl â‹† Î± : (p : ğŸ™) â†’ f (g p) â‰¡ p Î± â‹† = refl â‹† Î² :
        (p : â‹† â‰¡ â‹†) â†’ g (f p) â‰¡ p Î² (refl â‹†) = refl (refl â‹†)</p>
        <p>ğŸ™-isProp : (x y : ğŸ™) â†’ (x â‰¡ y) ğŸ™-isProp x y = let (f , ((g ,
        f-g) , (h , h-f))) = ğŸ™-â‰¡-â‰ƒ x y in h â‹†</p>
        <hr />
        <p>â€“ 2.9 Î -types and the function extensionality axiom</p>
        <p>happly : {A : ğ’° ğ’¾} {B : A â†’ ğ’° ğ’¿} {f g : (x : A) â†’ B x} â†’ f â‰¡
        g â†’ f âˆ¼ g happly p x = ap (Î» - â†’ - x) p</p>
        <p>has-funext : (ğ’¾ ğ’¿ : Level) â†’ ğ’° ((ğ’¾ âŠ” ğ’¿)âº) has-funext ğ’¾ ğ’¿ = {A
        : ğ’° ğ’¾} {B : A â†’ ğ’° ğ’¿} (f g : (x : A) â†’ B x) â†’ is-equiv (happly
        {ğ’¾} {ğ’¿} {A} {B} {f} {g})</p>
        <p>qinv-fe : has-funext ğ’¾ ğ’¿ â†’ {A : ğ’° ğ’¾} {B : A â†’ ğ’° ğ’¿} (f g : (x
        : A) â†’ B x) â†’ qinv happly qinv-fe fe f g = equivs-are-invs
        happly (fe f g)</p>
        <p>funext : {A : ğ’° ğ’¾} {B : A â†’ ğ’° ğ’¿} â†’ has-funext ğ’¾ ğ’¿ â†’ {f g : (x
        : A) â†’ B x} â†’ f âˆ¼ g â†’ f â‰¡ g funext fe {f} {g} htpy = let (funext
        , Î· , Îµ ) = qinv-fe fe f g in funext htpy</p>
        <p>â€“ Slightly generalized â‰¡fe-comp : {A : ğ’° ğ’¾} {B : A â†’ ğ’° ğ’¿} â†’
        (fe : has-funext ğ’¾ ğ’¿) â†’ {f g : (x : A) â†’ B x} â†’ (h : f âˆ¼ g) â†’
        happly (funext fe h) â‰¡ h â‰¡fe-comp fe {f} {g} h = let (funext , Î·
        , Îµ ) = qinv-fe fe f g in Î· h</p>
        <p>â‰¡fe-uniq : {A : ğ’° ğ’¾} {B : A â†’ ğ’° ğ’¿} â†’ (fe : has-funext ğ’¾ ğ’¿) â†’
        {f g : (x : A) â†’ B x} â†’ (p : f â‰¡ g) â†’ p â‰¡ funext fe (happly p)
        â‰¡fe-uniq fe {f} {g} p = let (funext , Î· , Îµ ) = qinv-fe fe f g
        in (Îµ p)â»Â¹</p>
        <p>tr-f : (X : ğ’° ğ’¾) (A : X â†’ ğ’° ğ’¿) (B : X â†’ ğ’° ğ“€) (xâ‚ xâ‚‚ : X) (p :
        xâ‚ â‰¡ xâ‚‚) (f : A xâ‚ â†’ B xâ‚) â†’ tr (Î» x â†’ (A x â†’ B x)) p f â‰¡ (Î» x â†’
        tr B p (f (tr A (p â»Â¹) x))) tr-f X A B xâ‚ xâ‚‚ (refl xâ‚) f = refl
        f</p>
        <hr />
        <p>â€“ 2.10 Universes and the univalence axiom</p>
        <p>â€“ I need this helper to delay the pattern match in
        <code>idtoeqv</code>, while â€“ still being able to use this same
        function in other places, like in â€“ the construction of
        <code>ua-âˆ˜</code>. idtoeqv-helper : {X Y : ğ’° ğ’¾} (p : X â‰¡ Y) â†’
        is-equiv (tr (Î» C â†’ C) p) idtoeqv-helper (refl X) =
        invs-are-equivs (ğ‘–ğ‘‘ X) (qinv-id-id X)</p>
        <p>idtoeqv : {X Y : ğ’° ğ’¾} â†’ X â‰¡ Y â†’ X â‰ƒ Y idtoeqv {ğ’¾} {X} {Y} p =
        tr (Î» C â†’ C) p , (idtoeqv-helper p)</p>
        <p>is-univalent : (ğ’¾ : Level) â†’ ğ’° (ğ’¾ âº) is-univalent ğ’¾ = (X Y :
        ğ’° ğ’¾) â†’ is-equiv (idtoeqv {ğ’¾} {X} {Y})</p>
        <p>qinv-ua : is-univalent ğ’¾ â†’ (X Y : ğ’° ğ’¾) â†’ qinv idtoeqv qinv-ua
        ua X Y = equivs-are-invs idtoeqv (ua X Y)</p>
        <p>ua : is-univalent ğ’¾ â†’ {X Y : ğ’° ğ’¾} â†’ X â‰ƒ Y â†’ X â‰¡ Y ua u {X}
        {Y} eqv = let (ua , idtoeqvâˆ˜ua , uaâˆ˜idtoeqv) = qinv-ua u X Y in
        ua eqv</p>
        <p>â€“ Helper idâˆ¼idtoeqvâˆ˜ua : (u : is-univalent ğ’¾) â†’ {X Y : ğ’° ğ’¾}
        (eqv : X â‰ƒ Y) â†’ eqv â‰¡ idtoeqv (ua u eqv) idâˆ¼idtoeqvâˆ˜ua u {X} {Y}
        eqv = let (ua , idtoeqvâˆ˜ua , uaâˆ˜idtoeqv) = qinv-ua u X Y in
        (idtoeqvâˆ˜ua eqv)â»Â¹</p>
        <p>â‰¡u-comp : (u : is-univalent ğ’¾) â†’ {X Y : ğ’° ğ’¾} (eqv : X â‰ƒ Y) (x
        : X) â†’ tr (Î» C â†’ C) (ua u eqv) x â‰¡ prâ‚ eqv x â‰¡u-comp u {X} {Y}
        eqv x = happly q x where p : idtoeqv (ua u eqv) â‰¡ eqv p =
        (idâˆ¼idtoeqvâˆ˜ua u eqv)â»Â¹ q : tr (Î» C â†’ C) (ua u eqv) â‰¡ prâ‚ eqv q
        = ap prâ‚ p</p>
        <p>â‰¡u-uniq : (u : is-univalent ğ’¾) â†’ {X Y : ğ’° ğ’¾} (p : X â‰¡ Y) â†’ p
        â‰¡ ua u (idtoeqv p) â‰¡u-uniq u {X} {Y} p = let (ua , idtoeqvâˆ˜ua ,
        uaâˆ˜idtoeqv) = qinv-ua u X Y in (uaâˆ˜idtoeqv p)â»Â¹</p>
        <p>ua-id : (u : is-univalent ğ’¾) â†’ {A : ğ’° ğ’¾} â†’ refl A â‰¡ ua u
        (â‰ƒ-refl A) ua-id u {A} = begin refl A â‰¡âŸ¨ â‰¡u-uniq u (refl A) âŸ© ua
        u (idtoeqv (refl A)) â‰¡âŸ¨âŸ© ua u (â‰ƒ-refl A) âˆ</p>
        <p>ua-âˆ˜ : (u : is-univalent ğ’¾) â†’ {X Y Z : ğ’° ğ’¾} (eqvf : X â‰ƒ Y)
        (eqvg : Y â‰ƒ Z) â†’ ua u eqvf âˆ™ ua u eqvg â‰¡ ua u (â‰ƒ-trans eqvf
        eqvg) ua-âˆ˜ u {X} {Y} {Z} eqvf eqvg = proof â»Â¹ where p = ua u
        eqvf q = ua u eqvg</p>
        <p>idtoeqv-âˆ™ : â‰ƒ-trans (idtoeqv p) (idtoeqv q) â‰¡ idtoeqv (p âˆ™ q)
        idtoeqv-âˆ™ = begin â‰ƒ-trans (idtoeqv p) (idtoeqv q) â‰¡âŸ¨âŸ© â‰ƒ-trans
        (tr (Î» C â†’ C) p , idtoeqv-helper p) (tr (Î» C â†’ C) q ,
        idtoeqv-helper q) â‰¡âŸ¨âŸ© ((tr (Î» C â†’ C) q) âˆ˜ (tr (Î» C â†’ C) p) ,
        â‰ƒ-trans-helper (idtoeqv p) (idtoeqv q)) â‰¡âŸ¨ pairâ¼((tr-âˆ˜ id p q) ,
        refl <em>) âŸ© (tr (Î» C â†’ C) (p âˆ™ q) , tr (Î» - â†’ is-equiv -) (tr-âˆ˜
        id p q) (â‰ƒ-trans-helper (idtoeqv p) (idtoeqv q)) ) â‰¡âŸ¨ pairâ¼(refl
        </em> , lemma p q) âŸ© (tr (Î» C â†’ C) (p âˆ™ q) , idtoeqv-helper (p âˆ™
        q)) â‰¡âŸ¨âŸ© idtoeqv (p âˆ™ q) âˆ where lemma : (p : X â‰¡ Y) (q : Y â‰¡ Z)
        â†’ tr is-equiv (tr-âˆ˜ id p q) (â‰ƒ-trans-helper (idtoeqv p) (idtoeqv
        q)) â‰¡ idtoeqv-helper (p âˆ™ q) lemma (refl X) (refl X) = refl
        _</p>
        <p>proof : ua u (â‰ƒ-trans eqvf eqvg) â‰¡ ua u eqvf âˆ™ ua u eqvg
        proof = begin ua u (â‰ƒ-trans eqvf eqvg) â‰¡âŸ¨ ap (Î» - â†’ ua u
        (â‰ƒ-trans - eqvg)) (idâˆ¼idtoeqvâˆ˜ua u eqvf) âŸ© ua u (â‰ƒ-trans
        (idtoeqv p) eqvg) â‰¡âŸ¨ ap (Î» - â†’ ua u (â‰ƒ-trans (idtoeqv p) -))
        (idâˆ¼idtoeqvâˆ˜ua u eqvg) âŸ© ua u (â‰ƒ-trans (idtoeqv p) (idtoeqv q))
        â‰¡âŸ¨ ap (Î» - â†’ ua u -) idtoeqv-âˆ™ âŸ© ua u (idtoeqv (p âˆ™ q)) â‰¡Ë˜âŸ¨
        â‰¡u-uniq u (p âˆ™ q) âŸ© ua u eqvf âˆ™ ua u eqvg âˆ</p>
        <p>â€“ Lemma for next theorem tr-<em>âˆ¼id : (fe : has-funext ğ’¾ ğ’¾) â†’
        {X : ğ’° ğ’¾} {f : X â†’ X} â†’ (h : f âˆ¼ id) â†’ tr (</em>âˆ¼ id) (funext fe
        h) h â‰¡ refl tr-<em>âˆ¼id fe {X} {f} h = begin tr (</em>âˆ¼ id)
        (funext fe h) h â‰¡âŸ¨ i âŸ© tr (<em>âˆ¼ id) (funext fe (happly (funext
        fe h))) h â‰¡âŸ¨ ii âŸ© tr (</em>âˆ¼ id) (funext fe (happly (funext fe
        h))) (happly (funext fe h)) â‰¡âŸ¨ iii (funext fe h) âŸ© refl âˆ where
        i = ap (Î» - â†’ tr (<em>âˆ¼ id) (funext fe -) h) (â‰¡fe-comp fe h)â»Â¹
        ii = ap (Î» - â†’ tr (</em>âˆ¼ id) (funext fe (happly (funext fe h)))
        -) (â‰¡fe-comp fe h)â»Â¹ iii : (p : f â‰¡ id) â†’ tr (<em>âˆ¼ id) (funext
        fe (happly p)) (happly p) â‰¡ refl iii (refl f) = ap (Î» - â†’ tr
        (</em>âˆ¼ id) - (happly (refl f))) (â‰¡fe-uniq fe (refl f))â»Â¹</p>
        <p>uaâ»Â¹ : has-funext ğ’¾ ğ’¾ â†’ (u : is-univalent ğ’¾) â†’ {X Y : ğ’° ğ’¾}
        (eqv : X â‰ƒ Y) â†’ (ua u eqv)â»Â¹ â‰¡ ua u (â‰ƒ-sym eqv) uaâ»Â¹ fe u {X}
        {Y} eqvf@(f , e) = sufficient (ua-âˆ˜ u eqvfâ»Â¹ eqvf âˆ™ claim2)
        where p = ua u eqvf eqvfâ»Â¹ = â‰ƒ-sym eqvf fâ»Â¹ = prâ‚ eqvfâ»Â¹ q = ua
        u eqvfâ»Â¹</p>
        <p>sufficient : (ua u eqvfâ»Â¹ âˆ™ ua u eqvf â‰¡ refl Y) â†’ (ua u
        eqvf)â»Â¹ â‰¡ ua u eqvfâ»Â¹ sufficient p = begin (ua u eqvf)â»Â¹ â‰¡Ë˜âŸ¨
        refl-left âŸ© refl Y âˆ™ (ua u eqvf)â»Â¹ â‰¡âŸ¨ ap (<em>âˆ™ (ua u eqvf)â»Â¹)
        (p â»Â¹) âŸ© (ua u eqvfâ»Â¹ âˆ™ ua u eqvf) âˆ™ (ua u eqvf)â»Â¹ â‰¡âŸ¨ âˆ™-assoc
        (ua u eqvfâ»Â¹) âŸ© ua u eqvfâ»Â¹ âˆ™ (ua u eqvf âˆ™ (ua u eqvf)â»Â¹) â‰¡âŸ¨ ap
        (ua u eqvfâ»Â¹ âˆ™</em>) (â»Â¹-rightâˆ™ (ua u eqvf)) âŸ© ua u eqvfâ»Â¹ âˆ™
        refl X â‰¡âŸ¨ refl-right âŸ© ua u eqvfâ»Â¹ âˆ</p>
        <p>claim1 : â‰ƒ-trans eqvfâ»Â¹ eqvf â‰¡ â‰ƒ-refl Y claim1 = pairâ¼ (i ,
        ii) where i : (f âˆ˜ fâ»Â¹) â‰¡ id i = funext fe (â‰ƒ-Î· eqvfâ»Â¹) id-equiv
        : is-equiv id id-equiv = tr is-equiv i (â‰ƒ-trans-helper eqvfâ»Â¹ (f
        , e)) g h : Y â†’ Y g = prâ‚ (prâ‚ id-equiv) h = prâ‚ (prâ‚‚ id-equiv)
        Î± = prâ‚‚ (prâ‚ id-equiv) Î² = prâ‚‚ (prâ‚‚ id-equiv)</p>
        <pre><code>ii : ((g , Î±) , (h , Î²)) â‰¡ ((id , refl) , (id , refl))
ii = pairÃ—â¼(pairâ¼(iia , iib) , pairâ¼(iic , iid))
 where
  iia : g â‰¡ id
  iia = funext fe Î±
  iib : tr (_âˆ¼ id) iia Î± â‰¡ refl
  iib = tr-_âˆ¼id fe Î±
  iic : h â‰¡ id
  iic = funext fe Î²
  iid : tr (_âˆ¼ id) iic Î² â‰¡ refl
  iid = tr-_âˆ¼id fe Î²</code></pre>
        <p>claim2 : ua u (â‰ƒ-trans eqvfâ»Â¹ eqvf) â‰¡ refl Y claim2 = ap (ua
        u) claim1 âˆ™ ((â‰¡u-uniq u (refl Y))â»Â¹)</p>
        <p>â€“ Note: Univalence could be expressed like this Univalence :
        ğ“¤Ï‰ Univalence = âˆ€ i â†’ is-univalent i</p>
        <hr />
        <p>â€“ 2.11 Identity type</p>
        <p>â€“ Lemma 2.11.2. trHomc- : {A : ğ’° ğ’¾} (a : A) {xâ‚ xâ‚‚ : A} (p :
        xâ‚ â‰¡ xâ‚‚) (q : a â‰¡ xâ‚) â†’ tr (Î» x â†’ a â‰¡ x) p q â‰¡ q âˆ™ p trHomc- a
        (refl <em>) (refl </em>) = refl-right â»Â¹</p>
        <p>trHom-c : {A : ğ’° ğ’¾} (a : A) {xâ‚ xâ‚‚ : A} (p : xâ‚ â‰¡ xâ‚‚) (q : xâ‚
        â‰¡ a) â†’ tr (Î» x â†’ x â‰¡ a) p q â‰¡ p â»Â¹ âˆ™ q trHom-c a (refl <em>)
        (refl </em>) = refl-right â»Â¹</p>
        <p>trHomâ”€ : {A : ğ’° ğ’¾} {xâ‚ xâ‚‚ : A} (p : xâ‚ â‰¡ xâ‚‚) (q : xâ‚ â‰¡ xâ‚) â†’
        tr (Î» x â†’ x â‰¡ x) p q â‰¡ p â»Â¹ âˆ™ q âˆ™ p trHomâ”€ (refl <em>) q = (ap
        (</em>âˆ™ refl _) refl-left âˆ™ refl-right) â»Â¹</p>
        <p>â€“ Theorem 2.11.3. tr-fxâ‰¡gx : {A : ğ’° ğ’¾} {B : ğ’° ğ’¿} (f g : A â†’
        B) {a aâ€™ : A} (p : a â‰¡ aâ€™) (q : f a â‰¡ g a) â†’ tr (Î» x â†’ f x â‰¡ g
        x) p q â‰¡ (ap f p)â»Â¹ âˆ™ q âˆ™ (ap g p) tr-fxâ‰¡gx f g (refl a) q =
        (refl-left)â»Â¹ âˆ™ (refl-right)â»Â¹</p>
        <p>â€“ Theorem 2.11.5. tr-xâ‰¡x-â‰ƒ : {A : ğ’° ğ’¾} {a aâ€™ : A} (p : a â‰¡
        aâ€™) (q : a â‰¡ a) (r : aâ€™ â‰¡ aâ€™) â†’ (tr (Î» x â†’ x â‰¡ x) p q â‰¡ r) â‰ƒ (q
        âˆ™ p â‰¡ p âˆ™ r) tr-xâ‰¡x-â‰ƒ {ğ’¾} {A} {a} {aâ€™} (refl a) q r = map ,
        invs-are-equivs map (mapâ»Â¹ , Îµ , Î·) where map : q â‰¡ r â†’ (q âˆ™
        refl a â‰¡ refl a âˆ™ r) map eq = refl-right âˆ™ eq âˆ™ (refl-left)â»Â¹
        mapâ»Â¹ : (q âˆ™ refl a â‰¡ refl a âˆ™ r) â†’ (q â‰¡ r) mapâ»Â¹ eqâ€™ =
        (refl-right)â»Â¹ âˆ™ eqâ€™ âˆ™ refl-left Îµ : map âˆ˜ mapâ»Â¹ âˆ¼ id Îµ eqâ€™ =
        begin refl-right âˆ™ ((refl-right)â»Â¹ âˆ™ eqâ€™ âˆ™ refl-left) âˆ™
        (refl-left)â»Â¹ â‰¡Ë˜âŸ¨ i âŸ© refl-right âˆ™ ((refl-right)â»Â¹ âˆ™ eqâ€™) âˆ™
        refl-left âˆ™ (refl-left)â»Â¹ â‰¡Ë˜âŸ¨ ii âŸ© refl-right âˆ™ (refl-right)â»Â¹ âˆ™
        eqâ€™ âˆ™ refl-left âˆ™ (refl-left)â»Â¹ â‰¡âŸ¨ iii âŸ© refl _ âˆ™ eqâ€™ âˆ™
        refl-left âˆ™ (refl-left)â»Â¹ â‰¡âŸ¨ iv âŸ© eqâ€™ âˆ™ refl-left âˆ™
        (refl-left)â»Â¹ â‰¡âŸ¨ v âŸ© eqâ€™ âˆ™ (refl-left âˆ™ (refl-left)â»Â¹) â‰¡âŸ¨ vi âŸ©
        eqâ€™ âˆ™ refl _ â‰¡âŸ¨ vii âŸ© eqâ€™ âˆ where i = ap (<em>âˆ™ (refl-left)â»Â¹)
        (âˆ™-assoc refl-right) ii = ap (Î» - â†’ - âˆ™ refl-left âˆ™
        (refl-left)â»Â¹) (âˆ™-assoc refl-right) iii = ap (Î» - â†’ - âˆ™ eqâ€™ âˆ™
        refl-left âˆ™ (refl-left)â»Â¹) (â»Â¹-rightâˆ™ refl-right) iv = ap (Î» - â†’
        - âˆ™ refl-left âˆ™ (refl-left)â»Â¹) refl-left v = âˆ™-assoc eqâ€™ vi = ap
        (eqâ€™ âˆ™</em>) (â»Â¹-rightâˆ™ refl-left) vii = refl-right Î· : mapâ»Â¹ âˆ˜
        map âˆ¼ id Î· eq = begin (refl-right)â»Â¹ âˆ™ (refl-right âˆ™ eq âˆ™
        (refl-left)â»Â¹) âˆ™ refl-left â‰¡Ë˜âŸ¨ i âŸ© (refl-right)â»Â¹ âˆ™ (refl-right
        âˆ™ eq) âˆ™ (refl-left)â»Â¹ âˆ™ refl-left â‰¡Ë˜âŸ¨ ii âŸ© (refl-right)â»Â¹ âˆ™
        refl-right âˆ™ eq âˆ™ (refl-left)â»Â¹ âˆ™ refl-left â‰¡âŸ¨ iii âŸ© refl _ âˆ™ eq
        âˆ™ (refl-left)â»Â¹ âˆ™ refl-left â‰¡âŸ¨ iv âŸ© eq âˆ™ (refl-left)â»Â¹ âˆ™
        refl-left â‰¡âŸ¨ v âŸ© eq âˆ™ ((refl-left)â»Â¹ âˆ™ refl-left) â‰¡âŸ¨ vi âŸ© eq âˆ™
        refl _ â‰¡âŸ¨ vii âŸ© eq âˆ where i = ap (<em>âˆ™ refl-left) (âˆ™-assoc
        ((refl-right)â»Â¹)) ii = ap (Î» - â†’ - âˆ™ (refl-left)â»Â¹ âˆ™ refl-left)
        (âˆ™-assoc ((refl-right)â»Â¹)) iii = ap (Î» - â†’ - âˆ™ eq âˆ™
        (refl-left)â»Â¹ âˆ™ refl-left) (â»Â¹-leftâˆ™ refl-right) iv = ap (Î» - â†’
        - âˆ™ (refl-left)â»Â¹ âˆ™ refl-left) refl-left v = âˆ™-assoc eq vi = ap
        (eq âˆ™</em>) (â»Â¹-leftâˆ™ refl-left) vii = refl-right</p>
        <hr />
        <p>â€“ 2.12 Coproducts</p>
        <p>â€“ ğŸ™-is-not-ğŸ˜ : ğŸ™ â‰¢ ğŸ˜ â€“ ğŸ™-is-not-ğŸ˜ p = tr id p â‹†</p>
        <p>â€“ â‚-is-not-â‚€ : â‚ â‰¢ â‚€ â€“ â‚-is-not-â‚€ p = ğŸ™-is-not-ğŸ˜ q â€“ where â€“
        f : ğŸš â†’ ğ’° lzero â€“ f â‚€ = ğŸ˜ â€“ f â‚ = ğŸ™ â€“ q : ğŸ™ â‰¡ ğŸ˜ â€“ q = ap f p</p>
        <hr />
        <p>â€“ 2.15 Universal properties</p>
        <p>â€“ Theorem 2.15.7. Î Î£-comm : {X : ğ’° ğ’¾} {A : X â†’ ğ’° ğ’¿} {P : (x :
        X) â†’ A x â†’ ğ’° ğ“€} â†’ has-funext ğ’¾ (ğ’¿ âŠ” ğ“€) â†’ ((x : X) â†’ Î£ a ê‰ (A x)
        , P x a) â‰ƒ (Î£ g ê‰ ((x : X) â†’ A x) , ((x : X) â†’ P x (g x)))
        Î Î£-comm {ğ’¾} {ğ’¿} {ğ“€} {X} {A} {P} fe = map , invs-are-equivs map
        (mapâ»Â¹ , Îµ , Î·) where map : ((x : X) â†’ Î£ a ê‰ (A x) , P x a) â†’ (Î£
        g ê‰ ((x : X) â†’ A x) , ((x : X) â†’ P x (g x))) map f = (Î» x â†’ prâ‚
        (f x)) , (Î» x â†’ prâ‚‚ (f x)) mapâ»Â¹ : (Î£ g ê‰ ((x : X) â†’ A x) , ((x
        : X) â†’ P x (g x))) â†’ ((x : X) â†’ Î£ a ê‰ (A x) , P x a) mapâ»Â¹ (g ,
        h) = Î» x â†’ (g x , h x) Îµ : map âˆ˜ mapâ»Â¹ âˆ¼ id Îµ (g , h) = refl _ Î·
        : mapâ»Â¹ âˆ˜ map âˆ¼ id Î· f = funext fe (Î» x â†’ (Î£-uniq (f x))â»Â¹)</p>

      </article>
    </div>
  </main>
</body>
<style>
  :root {
    --text-bg: #fff;
    --text-fg: #222;
    --shadow: #000;
    --primary: #0054F4;
    --secondary: #9C1BD6;
    --modal-bg: #ccccccaa;
    --warning-bg: #fef08a;
    --code-bg: var(--text-bg);
    --code-fg: var(--text-fg);
    --code-keyword: #BB3B13;
    --code-string: #d52753;
    --code-number: #8A1060;
    --code-module: #8A1060;
    --code-field: #9C1BD6;
    --code-constructor: #207B1D;
    --code-highlight: #F5DEB3;
    --search-selected: #e2e8f0;
    --details-summary: #b2ebf2;
    --details-open: #80deea;
    --depgraph-edge: #eee;
    --blockquote-bg: #d8b4fe;
  }

  .diagram-dark {
    display: none !important;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --text-bg: #282C34;
      --text-fg: #bfbfbf;
      --shadow: #475569;
      --primary: #61AFEF;
      --secondary: #C878DD;
      --modal-bg: #282C34aa;
      --warning-bg: #991b1b;
      --code-keyword: #E5C07B;
      --code-string: #E06C75;
      --code-number: #98C379;
      --code-module: #56B6C2;
      --code-field: #C878DD;
      --code-constructor: #98C379;
      --code-highlight: #ef444499;
      --search-selected: #474e5e;
      --details-summary: #5b21b6;
      --details-open: #4c1d95;
      --depgraph-edge: #474e5e;
      --blockquote-bg: #475569;
    }

    div.warning {
      --shadow: #7f1d1d;
    }

    input {
      background-color: #334155;
      border: 1px solid #475569;
      color: var(--text-fg);
    }

    body {
      scrollbar-color: #3b4454 #2b2e33;
    }

    .diagram-dark {
      display: block !important;
    }

    .diagram-light {
      display: none !important;
    }
  }

  table {
    margin: auto;
    border-collapse: collapse;
  }

  table td,
  table th {
    text-align: center;
    padding: 0px 1em 0px 1em;
    border: 1px solid black;
  }

  table th {
    border-bottom: 2px solid black;
  }

  table td {
    white-space: nowrap;
  }

  html {
    max-width: 100%;
  }

  body {
    font-family: "Inria Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    width: 100%;
    font-size: var(--font-size);
    overflow-x: clip;
    background-color: var(--text-bg);
    color: var(--text-fg);
  }

  div#post-toc-container {
    max-width: 120ch;
    margin: auto;
  }

  article a[href],
  div#return>a[href],
  div#top>a[href],
  aside#toc>div#toc-container ul a[href] {
    color: var(--primary);
    text-decoration: none;
  }

  article a[href]:hover,
  div#return>a[href]:hover,
  div#top>a[href]:hover,
  aside#toc>div#toc-container ul a[href]:hover {
    text-decoration: 2px currentColor underline !important;
  }

  article a[href]:visited,
  div#return>a[href]:visited,
  div#top>a[href]:visited,
  aside#toc>div#toc-container ul a[href]:visited {
    color: var(--secondary);
  }

  /* Aspects. */
  .Agda {
    /* NameKinds. */
    /* OtherAspects. */
    /* Standard attributes. */
    font-family: 'iosevka', 'Iosevka', 'Fantasque Sans Mono', 'Roboto Mono', monospace;
    font-weight: 400;
  }

  .Agda .Comment {
    color: var(--code-fg);
    font-style: italic;
  }

  .Agda .Background {
    background-color: var(--code-bg);
  }

  .Agda .Markup {
    color: var(--code-fg);
  }

  .Agda .Keyword {
    color: var(--code-keyword);
  }

  .Agda .String {
    color: var(--code-string);
  }

  .Agda .Number {
    color: var(--code-number);
  }

  .Agda .Symbol {
    color: var(--code-fg);
  }

  .Agda .PrimitiveType {
    color: var(--primary);
  }

  .Agda .Pragma {
    color: var(--code-fg);
  }

  .Agda .Bound {
    color: var(--code-fg) !important;
  }

  .Agda .Generalizable {
    color: var(--code-fg) !important;
  }

  .Agda .InductiveConstructor {
    color: var(--code-constructor) !important;
  }

  .Agda .CoinductiveConstructor {
    color: var(--code-constructor) !important;
  }

  .Agda .Datatype {
    color: var(--primary) !important;
  }

  .Agda .Field {
    color: var(--code-field) !important;
  }

  .Agda .Function {
    color: var(--primary) !important;
  }

  .Agda .Module {
    color: var(--code-module) !important;
  }

  .Agda .Postulate {
    color: var(--primary) !important;
  }

  .Agda .Primitive {
    color: var(--primary) !important;
  }

  .Agda .Record {
    color: var(--primary) !important;
  }

  .Agda .UnsolvedMeta {
    color: var(--code-fg);
    background: yellow;
  }

  .Agda .UnsolvedConstraint {
    color: var(--code-fg);
    background: yellow;
  }

  .Agda .TerminationProblem {
    color: var(--code-fg);
    background: #FFA07A;
  }

  .Agda .IncompletePattern {
    color: var(--code-fg);
    background: #F5DEB3;
  }

  .Agda .Error {
    color: red;
    text-decoration: underline;
  }

  .Agda .TypeChecks {
    color: var(--code-fg);
    background: #ADD8E6;
  }

  .Agda .ShadowingInTelescope {
    color: var(--code-fg);
    background: #808080;
  }

  .Agda .Deadcode {
    color: var(--code-keyword);
    font-weight: bold;
  }

  .Agda a {
    text-decoration: none;
  }

  .Agda a[href]:hover {
    text-decoration: 2px var(--primary) underline;
  }

  .Agda a[href]:target {
    animation: highlight 2.5s;
  }

  body.text-page .Agda {
    font-size: var(--code-font-size);
  }

  pre.Agda,
  div.sourceCode,
  pre {
    border-radius: 0;
    box-shadow: none;
    overflow-y: clip;
    margin: 0;
    padding: 1em;
    padding-top: 0.25em;
    padding-bottom: 0.25em;
    background-color: var(--code-bg);
    color: var(--code-fg);
    font-size: var(--code-font-size);
    max-width: 100%;
    overflow-x: auto;
  }
</style>

</html>
